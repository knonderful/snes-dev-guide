= Programming basics

== Operations and instructions

As mentioned in <<02_snes_architecture_overview.asciidoc#,SNES architecture overview>>, programs can be loaded into the SNES through the cartridge ROM.
Each _operation_ is represented by a byte.
An operation can be something like "add two values together" or "copy a value in memory from location A to location B".
Some operations take _arguments_, which are encoded in the bytes that follow the byte that identifies the operation.
Arguments are specific to the type of operation.
The argument to the "add" example above would be the number 15.
The operation together with its arguments forms an _instruction_.
An instruction is one unit of work that will be performed at a time by the CPU.
There are many different CPU instructions that the CPU supports.

== CPU registers

In order to be able to work with data, the CPU has a number of so-called _registers_.
The registers are used to temporarily hold values inside the CPU.
Different registers have different purposes.
The CPU inside the SNES is a Ricoh 5A22, which is an enhanced version of the 65816 by Western Design Center.
It is a 16-bit CPU, which means that its main "work" registers can hold 16-bit values.
This in contrast to the CPU in the NES which can only work with 8-bit numbers.
In general 16-bit processors can be more effective, since they can handle more data with a single operation.

The following is an overview of all registers inside the 65816.

.65816 registers
[cols="5,20,75",options="header"]
|===
| Short | Name             | Purpose
| A     | Accumulator      | Handles all arithmetic and logic.
| X     | Index X          | Register for indexing. Often used as a loop variable.
| Y     | Index Y          | Register for indexing. Often used to calculate addresses with a certain offset to a base address.
| P     | Processor Status | Processor flags, holds the results of tests and 65816 processing states.
| S     | Stack Pointer    | Points to the current location of the stack.
| DP    | Direct Page      | Points to the current page for direct addressing mode operations.
| PB    | Program Bank     | Holds the memory bank address of the current CPU instruction.
| PC    | Program Counter  | Holds the memory address of the current CPU instruction.
| DB    | Data Bank        | Holds the memory bank address of the data the CPU is accessing.
|===

It is not important to understand what all these registers do at this point.
In general the most commonly used registers are A, X and Y.

== Assemblers

Though it would be possible to write the code for the SNES entirely in binary form (byte-by-byte), this would be a very confusing and inefficient way to work, since the binary representation of the operations do not reflect what they do.
In order to get around this problem a more abstract instruction set has been defined.

An _assembler_ is a program that takes such abstract instructions and converts them into the _byte-code_ that the 65816 CPU can read.
In assembly language, each instruction is made up of a _mnemonic_ (a 'symbol' that describes the operation) and its parameters (if the operation takes any parameters).
An example of such a mnemonic is "Load a value into the A register": `LDA`.
The instruction "Load value 42 into the A register" would be: `LDA #42`.

There are many different assemblers, each with their own syntax, but most of them share the same concepts and they all use the same mnemonics.
In this documentation we will presume the syntax of Ville Helin's link:http://www.villehelin.com/wla.html[WLA DX] assembler, which is an open source assember that supports multiple target architectures, amongst which the 65816.

== General concepts

=== Addressing

Numbers are used everywhere in programming languages.
This is a natural phenomenon since the byte code itself can be expressed in numbers.

The most common type is a _byte_, which consists of 8 bits.
A _word_ consists of 16 bits, or 2 bytes.
The most-significant byte of a word is the one that holds the upper 8 bits and the least-significant byte holds the lower 8 bits.

Any memory inside a computer can be seen as a series of bytes.
A _memory address_ (or simply "address") is the location of a specific byte in memory.
So if we want to access some value that has been stored in memory, we can tell the CPU the address at which it is located and the CPU can apply the operation to that location in memory.
An address can also be expressed in a number.
How big this number is, depends on the size of the addressable memory.
For instance, if we would have one byte of address space, we could access up to 256 bytes (0 to 255).
A two-byte address space can account for 65536 bytes, and so forth.

So far we have presumed that a memory address points to a single byte.
However, a byte is not necessarily the unit behind an address location.
As we will see later in this document, an address can also point to a word (or any other unit, for that matter).
In this case a byte-sized address space can account for 256 words, or 512 bytes.

=== Numbers

Assemblers support different kinds of notations for numbers.
We will only consider the ones that are supported by WLA DX.

==== Decimal

Of course, numbers can be expressed in decimal notation.
Expressing the decimal value of 23 simply is `23`.

==== Binary

Numbers can also be expressed in binary form.
In this form every single bit of the byte is explicitly defined.
This can be useful if the individual bits inside a byte have different meanings.
In WLA DX a binary string starts with `%`, followed by all bits.

For example the decimal number 23 can be expressed by the binary string `%10111`.
In our examples we will often write add zero-padding until the next byte level to express the full value in memory better: `%00010111`.

==== Hexadecimal

The third way of expressing a number is hexadecimal notation.
Hexadecimal numbers start with `$`, followed by the hexadecimal value.
The hexadecimal value of 23 is `$17`.
As with binary, we will usually add zero-padding on the left until the next byte boundary to express the full dimension of the value in memory.

== In practice

As mentioned before, we will write all code in the style of WLA DX, but other assemblers have similar concepts.

The following is an example piece of WLA DX assembly code:

.Assembly code example
----
Start:
    lda #$00        ; Load 0 into A
    sta $2101       ; Store the current value of A (0) into the value at address $2101

    ldx $A020       ; Load the value at address $A020 into X
    dex             ; Decrease the value of X by one
    txa             ; Transfer the value of X to A
    jmp Start       ; Jump back to Start
----

The above code fragment illustrates different aspects of writing code for the WLA DX assembler.
The first line starts with a _label_ declaration.
In this case the label is called `Start`.
A label is a helper tool to make it easier for the developer to remember references to addresses in memory.
The last line in the example contains a reference to the previously-declared label `Start`.
When the code gets assembled, the assembler will substitute all references to labels with the address at which they were declared.
In the above example, if the location of `Start` in memory is `$10AA`, then the last line in the example will cause the program to jump back to location `$10AA` in memory.
Note that a label declaration writes no output to the target byte code; it is merely a helper for the programmer.

The second line in the example above declares the first CPU instruction.
In this case the mnemonic for "Load a value into the accumulator" (`lda`) is declared with the constant value `$00`.
When a number is prepended with `#` the value gets written directly to the register.

In contrast, the second instruction stores the value of A into the location `$2101` in memory.
When a number does not have a `#` prepended, it will get interpreted by the assembler as an address.

The third instruction demonstrates loading a value into a register from an address (note the missing `#`).

The fourth and fifth instructions take no parameters at all.
They decrease the current value of the X register by one and transfer the value from X to A, respectively.

The last instruction, as mentioned before, instructs the CPU to start executing the code that starts at the address of `Start`, resulting in an infinite loop.

Additionally, many lines contain comments.
A comment in WLA DX starts with a `;` and ends at the end of the line.
Comments serve only as an aid to the reader of the code and have no influence on the output byte code.
